// Generated by CoffeeScript 1.8.0

/*
Copyright 2015 Alexej Magura

This file is part of Bebopt (https://github.com/amagura/bebopt)

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
 */

(function() {
  'use strict';
  var Bebopt, basename, clone, util,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  util = require('util');

  clone = require('clone');

  basename = require('path').basename;

  Bebopt = (function() {
    function Bebopt(app) {
      this.app = app;
      this.parse = __bind(this.parse, this);
      this._clean = __bind(this._clean, this);
      this._runCallbacks = __bind(this._runCallbacks, this);
      this._gather = __bind(this._gather, this);
      this._bindOptToList = __bind(this._bindOptToList, this);
      this._resolveOpts = __bind(this._resolveOpts, this);
      this._takesArg = __bind(this._takesArg, this);
      this._splitCombinedShorts = __bind(this._splitCombinedShorts, this);
      this._setOptionArg = __bind(this._setOptionArg, this);
      this._getOption = __bind(this._getOption, this);
      this._catchInvalidOpt = __bind(this._catchInvalidOpt, this);
      this._catchSpaceDelimArgs = __bind(this._catchSpaceDelimArgs, this);
      this.usage = __bind(this.usage, this);
      this.printHelp = __bind(this.printHelp, this);
      this._makeHelp = __bind(this._makeHelp, this);
      this._parentOrChildUsage = __bind(this._parentOrChildUsage, this);
      this.help = __bind(this.help, this);
      if (this.app == null) {
        this.app = basename(process.argv[1]);
      }
      this._options = [];
      this._parent = null;
      this._raw = process.argv;
      this._cooked = [];
      this._eaten = {};
      this.usage = void 0;
      this._help = [];
    }

    Bebopt.prototype._beatError = function(parent, name) {
      var err;
      switch (parent) {
        case 'long':
          if (name.length < 2) {
            err = "Bebopt: option name too short -- '" + name + "'";
            throw new Error(err);
          }
          return false;
        case 'short':
          if (name.length > 1) {
            err = "Bebopt: option name too long: '" + name + "'";
            throw new Error(err);
          }
          return false;
      }
    };

    Bebopt.prototype._makeOpt = function(name) {
      var new_op, op;
      new_op = name.replace(/^.*?([:]*)$/, '$1');
      name = name.replace(/^(.*?)[:]*$/, '$1');
      if (new_op === '::') {
        op = 'optarg';
      } else if (new_op === ':') {
        op = 'arg';
      } else {
        op = 'flag';
      }
      return {
        op: op,
        name: name
      };
    };

    function _makeFun(context, name, cb) {
    context.prototype[name] = cb;
    return context;
  };

    ['shortBeat', 'longBeat'].forEach(function(funcName) {
      var listName;
      listName = funcName.replace(/Beat/, '');
      return _makeFun(Bebopt, funcName, function(_name, fn) {
        var child, index, name, op, option, self, _base, _ref;
        self = this;
        _ref = self._makeOpt(_name), op = _ref.op, name = _ref.name;
        self._beatError(listName, name);
        if (fn === void 0) {
          if ((_base = self._parent).type == null) {
            _base.type = op;
          }
          child = clone(self._parent);
          child.parent = self._parent;
          child.parent.index = child.index;
          ++child.index;
          child.name = name;
          child.list = listName;
          child.arg = void 0;
          self._parent.child = child;
          self._options.push(child);
        } else {
          option = {
            cb: fn,
            type: op,
            name: name,
            list: listName,
            child: null,
            parent: null,
            arg: void 0
          };
          self._options.push(option);
          index = self._options.length - 1;
          option = self._options.pop();
          option.index = index;
          self._options.push(option);
        }
        self._parent = self._options.slice(-1)[0];
        return self;
      });
    });

    Bebopt.prototype.help = function(text) {
      var err;
      if (this._parent === null) {
        err = 'Bebopt: null parent ref: cannot apply';
        throw new Error(err);
      }
      this._parent.usage = text;
      this._parent = null;
      return this;
    };

    Bebopt.prototype._parentOrChildUsage = function(opt) {
      if (typeof opt.usage !== 'string') {
        if (opt.parent === null) {
          if (opt.child === null) {
            return '';
          } else {
            return this._options[opt.child.index].usage;
          }
        } else {
          return this._options[opt.parent.index].usage;
        }
      } else {
        return opt.usage;
      }
    };

    Bebopt.prototype._makeHelp = function() {
      return this._options.forEach((function(_this) {
        return function(opt) {
          var dashes, usage;
          dashes = opt.list === 'short' ? '-' : '--';
          usage = _this._parentOrChildUsage(opt);
          if (opt.child === null) {
            if (opt.parent === null) {
              return _this._help.push("  " + dashes + opt.name + usage);
            }
          } else {
            if (opt.parent === null) {
              if (dashes === '--') {
                return _this._help.push("  -" + opt.child.name + ", " + dashes + opt.name + usage);
              } else {
                return _this._help.push("  " + dashes + opt.name + ", --" + opt.child.name + usage);
              }
            }
          }
        };
      })(this));
    };

    Bebopt.prototype.printHelp = function(fn) {
      var usage;
      usage = this.usage === void 0 ? "Usage: " + this.app : this.usage;
      if (fn === void 0) {
        console.error(usage);
        return this._help.forEach(function(txt) {
          return console.error(txt);
        });
      } else {
        fn(usage);
        return this._help.forEach(function(txt) {
          return fn(txt);
        });
      }
    };

    Bebopt.prototype.usage = function(text) {
      return this.usage = text;
    };

    Bebopt.prototype._sepOptArg = function(opt) {
      var arg, _opt;
      if (/=/.test(opt)) {
        arg = opt.replace(/.*?=(.*)/, '$1');
      } else {
        arg = void 0;
      }
      _opt = opt.replace(/(.*)?=.*/, '$1');
      return {
        opt: _opt,
        _arg: arg
      };
    };

    Bebopt.prototype._catchSpaceDelimArgs = function(opt, list) {
      var type;
      type = this._getOption(opt, list).type;
      if (type !== 'flag') {
        if (opt.optarg === void 0) {
          this._args.forEach((function(_this) {
            return function(nonOpt, ind) {
              if (nonOpt.index === (opt.index + 1)) {
                opt.optarg = nonOpt.arg;
                return delete _this._args[ind];
              }
            };
          })(this));
        }
      }
      return opt;
    };

    Bebopt.prototype._catchInvalidOpt = function(opt, list) {
      var option;
      option = this._getOption(opt, list);
      if (list === 'short' && option === void 0) {
        console.error("" + this.app + ": invalid option -- '" + opt.arg + "'");
        return process.exit(1);
      } else if (list === 'long' && option === void 0) {
        console.error("" + this.app + ": unrecognized option '--" + opt.arg + "'");
        return process.exit(1);
      }
    };

    Bebopt.prototype._syncIndexes = function(list, gte) {
      list.forEach(function(elem) {
        if (elem.index >= gte) {
          return ++elem.index;
        }
      });
      return list;
    };

    Bebopt.prototype._getOption = function(opt, listName) {
      var option;
      option = this._options.filter(function(mem) {
        if (opt.arg === mem.name && listName === mem.list) {
          return mem;
        }
      });
      return option.length === 0 ? undefined : option[0];
    };

    Bebopt.prototype._setOptionArg = function(opt, listName) {
      var option;
      option = this._getOption(opt, listName);
      option.arg = opt.optarg;
      if (option.child !== null) {
        this._options[option.child.index].arg = opt.optarg;
      }
      if (option.parent !== null) {
        this._options[option.parent.index].arg = opt.optarg;
      }
      return void 0;
    };

    Bebopt.prototype._splitCombinedShorts = function() {
      return this._opts.forEach((function(_this) {
        return function(elem, ind) {
          var dashes, opts, _elem, _results;
          dashes = elem.arg.replace(/^(--?).*/, '$1').length;
          if (dashes === 1) {
            opts = elem.arg.replace(/^-(.*)/, '$1').split('');
            opts = opts.reverse();
            elem.arg = opts.pop();
            _results = [];
            while (opts.length > 0) {
              _elem = clone(elem);
              _elem.arg = opts.pop();
              if (_this._args[_elem.index] !== void 0) {
                _this._syncIndexes(_this._args, _elem.index);
              }
              _this._syncIndexes(_this._opts, _elem.index + 1);
              ++_elem.index;
              console.log(_elem);
              _results.push(_this._opts.push(_elem));
            }
            return _results;
          }
        };
      })(this));
    };

    Bebopt.prototype._takesArg = function(opt, listName) {
      var type;
      this._catchInvalidOpt(opt, listName);
      type = this._getOption(opt, listName).type;
      if (type !== 'flag') {
        return true;
      } else {
        return false;
      }
    };

    Bebopt.prototype._log = function(y) {
      return console.log(util.inspect(y, {
        colors: true,
        depth: null
      }));
    };

    Bebopt.prototype._resolveOpts = function() {
      this._splitCombinedShorts();
      return this._opts.forEach((function(_this) {
        return function(elem, ind) {
          var dashes, option;
          dashes = elem.arg.replace(/^(--?).*/, '$1').length;
          elem.arg = elem.arg.replace(/^--?(.*)/, '$1');
          if (dashes === 2) {
            if (_this._takesArg(elem, 'long')) {
              elem = _this._catchSpaceDelimArgs(elem, 'long');
            }
            _this._bindOptToList(elem, 'long');
            option = _this._getOption(elem, 'long');
            return _this._cooked.push(option);
          } else {
            if (_this._takesArg(elem, 'short')) {
              elem = _this._catchSpaceDelimArgs(elem, 'short');
            }
            _this._bindOptToList(elem, 'short');
            option = _this._getOption(elem, 'short');
            return _this._cooked.push(option);
          }
        };
      })(this));
    };

    Bebopt.prototype._bindOptToList = function(opt, listName) {
      var err, type;
      type = this._getOption(opt, listName).type;
      if (type === 'arg') {
        if (opt.optarg === void 0) {
          err = "" + this.app + ": ";
          if (listName === 'short') {
            err += "option requires an argument -- '" + opt.arg + "'";
          } else {
            err += "option '--" + opt.arg + "' requires an argument";
          }
          console.error(err);
          return process.exit(1);
        } else {
          return this._setOptionArg(opt, listName);
        }
      } else if (type === 'optarg') {
        return this._setOptionArg(opt, listName);
      } else if (type === 'flag') {
        if (opt.optarg !== void 0) {
          err = "" + this.app;
          err += "option '--" + opt.arg + "' doesn't allow an argument";
          console.error(err);
          return process.exit(1);
        } else {
          opt.optarg = true;
          return this._setOptionArg(opt, listName);
        }
      }
    };

    Bebopt.prototype._gather = function() {
      var noopt, optend;
      this._opts = [];
      this._args = [];
      optend = false;
      noopt = false;
      return process.argv.slice(2).forEach((function(_this) {
        return function(arg, ind, arr) {
          var opt, _arg, _ref;
          if (/^--$/.test(arg)) {
            return optend = true;
          } else if (/^-$/.test(arg)) {
            return noopt = true;
          } else {
            if (noopt) {
              null;
            }
            if (optend || /^[^-]+/.test(arg) === true) {
              return _this._args.push({
                arg: arg,
                index: ind
              });
            } else {
              _ref = _this._sepOptArg(arg), opt = _ref.opt, _arg = _ref._arg;
              return _this._opts.push({
                arg: opt,
                optarg: _arg,
                index: ind
              });
            }
          }
        };
      })(this));
    };

    Bebopt.prototype._runCallbacks = function() {
      return this._cooked.forEach((function(_this) {
        return function(opt) {
          var arg;
          arg = opt.cb.apply(_this, [opt.arg]);
          _this._eaten[opt.name] = arg;
          if (opt.child !== null) {
            _this._eaten[opt.child.name] = arg;
          }
          if (opt.parent !== null) {
            return _this._eaten[opt.parent.name] = arg;
          }
        };
      })(this));
    };

    Bebopt.prototype._clean = function() {
      return Object.keys(this).forEach((function(_this) {
        return function(key) {
          if (/^_/.test(key)) {
            switch (key) {
              case '_runCallbacks':
                return null;
              case '_raw':
                return null;
              case '_cooked':
                return null;
              case '_eaten':
                return null;
              case '_help':
                return null;
              default:
                return delete _this[key];
            }
          }
        };
      })(this));
    };

    Bebopt.prototype.parse = function() {
      this._makeHelp();
      this._gather();
      this._resolveOpts();
      this._clean();
      this._runCallbacks();
      return this._eaten;
    };

    return Bebopt;

  })();

  module.exports = Bebopt;

}).call(this);
